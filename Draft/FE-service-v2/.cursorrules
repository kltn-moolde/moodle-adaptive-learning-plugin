# Cursor Rules for Adaptive Learning Frontend

## Project Overview
This is a React + TypeScript frontend application that integrates with Moodle LMS via LTI (Learning Tools Interoperability) and provides adaptive learning paths with AI-powered explanations. The application uses Kong Gateway for authentication and includes role-based dashboards for Students, Instructors, and Admins.

## Technology Stack
- **Framework**: React 19 with TypeScript
- **Build Tool**: Vite 7
- **Routing**: React Router DOM v6
- **Styling**: Tailwind CSS (via inline classes)
- **Authentication**: JWT via Kong Gateway
- **LTI**: Moodle LTI 1.3 Integration
- **State Management**: React Hooks (useState, useEffect)
- **API Communication**: Fetch API

## Code Style & Conventions

### TypeScript
- Use strict TypeScript typing
- Define interfaces for all data structures
- Use `type` for unions and intersections
- Prefer interfaces over type for objects
- Always define return types for functions
- Use optional chaining (`?.`) and nullish coalescing (`??`)

### React Components
- Use functional components with hooks
- Use PascalCase for component names
- Extract reusable logic into custom hooks
- Use `React.FC` for component typing
- Props interfaces should be named `{Component}Props`
- Keep components focused and single-responsibility

### File Naming
- Components: PascalCase (e.g., `StudentDashboard.tsx`)
- Services: camelCase (e.g., `kongApiService.ts`)
- Types: PascalCase (e.g., `index.ts`)
- Utils: camelCase with descriptive names

### Import Order
1. React imports
2. Third-party imports
3. Local component imports
4. Local service imports
5. Types/interfaces
6. Constants/utils
7. Styles

### Code Structure
```typescript
// 1. Imports
import React, { useState, useEffect } from 'react';
import type { User } from '../types';

// 2. Interfaces/Types
interface MyComponentProps {
  userId: number;
  courseId: number;
}

// 3. Component
export const MyComponent: React.FC<MyComponentProps> = ({ userId, courseId }) => {
  // 4. Hooks
  const [state, setState] = useState(null);
  
  // 5. Effects
  useEffect(() => {
    // Effect logic
  }, [dependencies]);
  
  // 6. Handlers
  const handleClick = () => {
    // Handler logic
  };
  
  // 7. Render
  return (
    // JSX
  );
};
```

## Project Structure

```
src/
â”œâ”€â”€ components/      # Reusable UI components
â”‚   â”œâ”€â”€ auth/       # Authentication components
â”‚   â”œâ”€â”€ lti/        # LTI-specific components
â”‚   â””â”€â”€ ...         # Other components
â”œâ”€â”€ pages/          # Page-level components (dashboards)
â”œâ”€â”€ services/       # API service classes
â”‚   â”œâ”€â”€ kongApiService.ts
â”‚   â”œâ”€â”€ ltiService.ts
â”‚   â”œâ”€â”€ learningPathService.ts
â”‚   â”œâ”€â”€ moodleApiService.ts
â”‚   â””â”€â”€ ...
â”œâ”€â”€ types/          # TypeScript type definitions
â”œâ”€â”€ data/           # Mock data for development
â””â”€â”€ assets/         # Static assets
```

## API Service Patterns

### Service Class Pattern
- Create service classes with singleton pattern
- Export singleton instance
- Use environment variables for base URLs
- Include error handling and logging
- Return typed responses

```typescript
export class MyService {
  private baseURL: string;
  
  constructor(baseURL: string = import.meta.env.VITE_API_URL) {
    this.baseURL = baseURL;
  }
  
  async getData(id: number): Promise<DataType> {
    try {
      const response = await fetch(`${this.baseURL}/endpoint/${id}`);
      if (!response.ok) throw new Error('Failed');
      return await response.json();
    } catch (error) {
      console.error('Error:', error);
      throw error;
    }
  }
}

export const myService = new MyService();
```

## LTI Integration

### LTI Flow
1. Receive LTI parameters from Moodle via POST
2. Store parameters in sessionStorage
3. Call `/auth/lti` endpoint for authentication
4. Store JWT token in localStorage
5. Redirect to appropriate dashboard based on role

### Role Mapping
- `Student` â†’ STUDENT role â†’ Student Dashboard
- `Instructor` or `Teacher` â†’ INSTRUCTOR role â†’ Instructor Dashboard
- `Administrator` â†’ ADMIN role â†’ Admin Dashboard

## Kong Gateway Integration

### Authentication
- All API calls (except auth endpoints) require JWT Bearer token
- Token stored in localStorage as `auth_token`
- Include in headers: `Authorization: Bearer ${token}`
- Auto-refresh expired tokens

### Base URL
- Development: `http://localhost:8000`
- Production: Set via environment variable

## Component Best Practices

### Dashboard Components
- Fetch data in `useEffect` with proper dependencies
- Show loading states during data fetch
- Display error messages for failures
- Use mock data as fallback for development

### Conditional Rendering
```typescript
if (loading) return <LoadingSpinner />;
if (error) return <ErrorMessage error={error} />;
if (!data) return <NoDataMessage />;
return <DataDisplay data={data} />;
```

### Role-Based Rendering
- Use user role to conditionally render components
- Check role before allowing actions
- Redirect unauthorized access attempts

## Styling Conventions

### Tailwind CSS Classes
- Use inline Tailwind classes
- Group related classes: layout â†’ spacing â†’ colors â†’ other
- Use conditional classes with template literals
- Responsive prefixes: `sm:`, `md:`, `lg:`

Example:
```typescript
<div className={`flex items-center space-x-2 p-4 rounded-lg ${
  isActive ? 'bg-blue-500 text-white' : 'bg-gray-100'
}`}>
```

### Color Scheme
- Primary: `primary-500`, `primary-600` (blue shades)
- Success: `green-500`, `green-600`
- Warning: `yellow-500`, `yellow-600`
- Error: `red-500`, `red-600`
- Background: `gray-50`, `gray-100`

## Error Handling

### API Errors
- Catch and log errors
- Show user-friendly messages
- Provide retry mechanisms
- Use fallback data when appropriate

### LTI Errors
- Check for LTI context
- Validate LTI parameters
- Handle missing or invalid parameters
- Show error UI with retry option

## Development Guidelines

### Environment Variables
- Always use `import.meta.env.VITE_*` for env vars
- Provide defaults for development
- Never commit `.env` file
- Document all env vars in `.env.example`

### Console Logging
- Use descriptive console logs for debugging
- Include emojis for log categorization (ðŸš€, âœ…, âŒ, âš ï¸)
- Remove or comment production logs
- Use console.error for errors

### Code Comments
- Comment complex logic
- Explain business rules
- Document API integrations
- Include JSDoc for functions

## Testing Considerations

### Manual Testing
- Test LTI launch flow
- Test role-based access
- Test API integrations
- Test responsive design

### Test Files
- Use `/public/lti-test.html` for LTI testing
- Mock backend services for development
- Test with real data in staging

## Git Workflow

### Commit Messages
- Use conventional commits
- Prefix with type: `feat:`, `fix:`, `docs:`, `refactor:`
- Be descriptive about changes

### Branch Strategy
- `main`: Production-ready code
- Feature branches: New features
- Fix branches: Bug fixes

## Performance

### Optimization
- Use React.memo for expensive components
- Lazy load routes with React.lazy
- Optimize images and assets
- Minimize bundle size

### Best Practices
- Avoid unnecessary re-renders
- Use useEffect dependencies correctly
- Clean up subscriptions and timers
- Optimize API calls

## Security

### Data Protection
- Never expose sensitive data in logs
- Use HTTPS in production
- Validate all user inputs
- Sanitize data before display

### Authentication
- Store tokens securely
- Implement token refresh
- Logout on 401 errors
- Clear data on logout

## API Endpoints Reference

### Authentication
- POST `/auth/lti` - LTI authentication
- POST `/auth/login` - Standard login
- POST `/auth/validate` - Validate token
- POST `/auth/refresh` - Refresh token
- GET `/auth/health` - Health check

### Learning Path
- POST `/api/suggest-action` - Get suggested action
- POST `/api/learning-path/explain` - AI explanation

### User Management
- GET `/api/users` - List users
- GET `/api/users/:id` - Get user
- GET `/auth/me` - Current user

### Course Management
- GET `/api/courses` - List courses
- GET `/api/courses/:id` - Get course

## Common Patterns

### Loading States
```typescript
const [loading, setLoading] = useState(true);
useEffect(() => {
  const loadData = async () => {
    setLoading(true);
    try {
      const data = await fetchData();
      setData(data);
    } catch (error) {
      setError(error.message);
    } finally {
      setLoading(false);
    }
  };
  loadData();
}, [dependencies]);
```

### Form Handling
```typescript
const [formData, setFormData] = useState({});
const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  setFormData({ ...formData, [e.target.name]: e.target.value });
};
const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault();
  await submitForm(formData);
};
```

## Questions to Consider

Before making changes, ask:
1. Does this follow the project's architecture?
2. Is the code type-safe?
3. Are errors handled gracefully?
4. Is the UI responsive?
5. Does it work with LTI integration?
6. Is it properly tested?
7. Are console logs appropriate?

## When Working on This Project

- Always check existing patterns before creating new ones
- Follow TypeScript strict mode
- Test LTI integration in development
- Ensure role-based access is enforced
- Keep components small and focused
- Write self-documenting code
- Add comments for complex logic
- Use environment variables for configuration
- Follow Tailwind CSS class ordering
- Handle async operations properly

## AI Helper Guidelines

When you need help with this project:
- Understand the LTI flow before making changes
- Check role-based authorization
- Verify API service methods exist
- Follow the established file structure
- Use the service singleton pattern
- Implement proper error handling
- Add loading states for async operations
- Test role-based rendering
- Ensure environment variables are set

